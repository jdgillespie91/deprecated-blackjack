--

TOC
1. Template
2. Conventions
3. Functions

--

1. Template

Document functions in the following way:

*** Status flag indicating whether function is ready to write ***
my_function(argument_1, argument_2, ...)
- Description of arguments
- Description of return values.
- Short description of what the function does (if not obvious from the previous sections).

For example, 

*** Ready to write ***
convert_temperature_celsius_to_fahrenheit(temperature_in_celsius) 
- temperature_in_celsius is a float.
- Returns a float corresponding to the temperature in fahrenheit.
- The function converts its argument to temperature in fahrenheit by scaling appropriately.

2. Conventions

These conventions are fairly loose so feel free to ignore them. In general though:
- For functions that get a quantity from somewhere, prefix with get_ (e.g. get_number_of_players gets an integer from user input, get_deck gets a list of integers).
- For functions that do something to an existing quantity, prefix with do_ (e.g. do_deal deals the cards).
- For functions that return a boolean value after checking a quantity, prefix with is_.
- For functions that print output to the terminal, prefix with print_.
- For functions that log output, prefix with log_.

3. Functions

*** Done ***
play_blackjack(manual_flag, number_of_games)
- manual_flag is a boolean and number_of_games is a integer.
- Returns a list of integers.
- manual_flag is True if manual mode is on and False if auto mode is on. number_of_games is the number of games to be executed. The list of integers returned indicate the results of every game (each element corresponds to a specific game and the list has number_of_games elements).

*** Done ***
get_number_of_players()
- Takes no arguments.
- Returns a positive integer.
- The function should accept user input, check that it is a valid input (make sure it is a 'sensible' number) and return if so.

*** Done ***
get_number_of_decks()
- Takes no arguments.
- Returns a positive integer.
- The function should accept user input, check that it is a valid input (make sure it is a sensible number) and return if so.

*** Done *** 
game(manual_flag, number_of_players, number_of_decks, number_of_automated_runs = 1)
- manual_flag is a boolean, number_of_players and number_of_decks are positive integers, and number_of_automated_runs is a positive integer with default value 1.
- Returns a list of integers.
- game(...) plays number_of_automated_runs rounds of blackjack and returns a list containing the outcome of every game (where 0 indicates a player loss, 1 a draw, and 2 a player win). For now, we shall use a single list and append each result to it (the alternative is to use a list of lists and have each inner list correspond to a single game).

*** Ready to write ***
print_results(results)
- results is a list of integers.
- No return value.
- Prints the outcome for each element in results. 0 corresponds to a player loss, 1 to a draw and 2 to a player win.

*** Ready to write ***
get_deck(number_of_decks)
- number_of_decks is an integer.
- Returns a list of class Card instances.
- The return should be a list of integers generated by replicating the integers 1-52 number_of_decks times and then shuffling (using the shuffle function from the module random if I recall correctly).

*** Ready to write ***
do_deal_deck(deck, number_of_players)
- deck is a list of class Card instances and number_of_players is a positive integer.
- Returns a list of lists.
- The outer list should contain number_of_players + 1 lists (don't forget the dealer!). The inner lists should each correspond to a hand and should contain 2 class Card instances. The first inner list should be player 1's hand, the second player 2's hand, and so on. The final inner list should be the dealer's hand.

*** Done ***
print_hands(hands)
- Takes a list of lists of Cards
- No return value.
- Prints the current state of the game; that is, it should print each player hand and the first of the dealer's two cards. The format of this print is entirely flexible but just bear in mind that it should be user-friendly.

*** Done ***
generate_card_pictures(hand)
- Takes a list of cards
- Returns an array of 4 unicode strings
- Builds 4 strings which when printed in sequence make a picture of all the cards in the hand.

*** Done ***
do_player_turn_manual(hand)
- Takes a list of class Card instances.
- Returns a positive integer.
- Takes a hand, prints the current state of the game and then calls get_decision to determine a decision based on that hand. This continues until the player stands or is bust and then the total is returned.

*** Done ***
do_player_turn_auto(hand)
- Takes a list of class Card instances.
- Returns a positive integer.
- Takes a hand and automatically determines decisions based on that hand (by calling the get_decision function).This continues until the player stands or is bust and then the total is returned.

*** Done ***
do_dealer_turn(hand)
- Takes a list of two class Card instances.
- Returns a nonnegative integer.
- Executes the dealer strategy as per casino rules. We use the "H17" strategy (dealer hits soft 17). Returns the total if it's between 17 and 21 (and not soft 17), a 0 if bust and a 1 if blackjack.

*** Done ***
is_blackjack(hand)
- Takes a list of two class Card instances.
- Returns a boolean.
- Takes a hand and checks if the hand is blackjack. Returns True if blackjack and False if not.

*** Ready to write ***
do_hit(hand, deck)
- Takes two lists of class Card instances.
- Returns a list of class Card instances.
- The first list is the hand and the second list is the deck. Takes the first card in the playing deck and appends it to hand. Returns hand. Note that we use append since we don't know the final length of hand and so cannot preassign its length. It might be worth considering preassigning its length to something large (presumably 21 should be its maximum length - 21 aces) but that may be costly in terms of storage and not save much time. This is a very minor issue though.

*** Done ***
get_decision(hand)
- Takes a list of class Card instances.
- Returns an integer.
- Takes a hand, determines the available decisions by calling get_available_decisions(hand), determines the decision to proceed with (in auto mode, this process still needs defining, but in manual mode, we'll just accept input from the terminal) and returns the integer corresponding to that decision. Currently, 0 corresponds to standing and 1 corresponds to hitting.

*** Done ***
get_available_decisions(hand)
- Takes a list of class Card instances.
- Return a list of lists.
- Needs to look at the hand and determine what moves are legitimate and return this information. The information is returned in a list of lists where each inner list contains an integer corresponding to a decision and a string identifying what that decision is. Currently, 0 corresponds to standing and 1 corresponds to hitting. 

*** Done ***    
do_determine_results(hand_totals)
- Takes a list of integers.
- Returns a list of integers.
- The input will be a list of integers that correspond to hand totals. The final integer is the dealer's total. Starting at the first element in the list, each element is compared to the final element and 0 is appended to a list of results if that element is "worse" (worse in the sense that it is a weaker hand in blackjack terms), 1 if it is the same, and 2 if it is stronger (i.e. loss, draw and win). The final list of results will be one element shorter than the input list. This list of results is returned and describes the outcome of the game.

*** Done ***
get_hand_total(hand)
- Takes a list of class Card instances.
- Returns an integer.
- Returns the sum of the value attributes of each Card instance in the list.